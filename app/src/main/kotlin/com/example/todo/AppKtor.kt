package com.example.todo

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import io.konform.validation.Invalid
import io.konform.validation.Validation
import io.konform.validation.ValidationError
import io.konform.validation.constraints.*
import io.ktor.http.*
import io.ktor.serialization.jackson.*
import io.ktor.server.application.*
import io.ktor.server.engine.*
import io.ktor.server.jetty.jakarta.*
import io.ktor.server.plugins.calllogging.*
import io.ktor.server.plugins.contentnegotiation.*
import io.ktor.server.plugins.statuspages.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.slf4j.event.Level

fun main(args: Array<String>) {
    // Create virtual thread executor for handling requests
    // val virtualThreadExecutor = Executors.newVirtualThreadPerTaskExecutor()

    // io.ktor.server.jetty.jakarta.EngineMain.main(args)
    // io.ktor.server.netty.EngineMain.main(args)

    // embeddedServer(Netty, port = 8080, module = Application::module).start(wait = true)
    embeddedServer(Jetty, port = 8080, module = Application::module).start(wait = true)
}

fun Application.module() {
    configureLogging()
    configureSerialization()
    install(StatusPages)
    configureRouting()
}

fun Application.configureLogging() {
    install(CallLogging) {
        level = Level.INFO
        filter { call -> call.request.path().startsWith("/") }
        format { call ->
            val status = call.response.status()
            val httpMethod = call.request.httpMethod.value
            val userAgent = call.request.headers["User-Agent"]
            val threadName = Thread.currentThread().name
            "$status: $httpMethod - ${call.request.path()} [$threadName] $userAgent"
        }
    }
}

fun Application.configureSerialization() {
    install(ContentNegotiation) {
        jackson {
            enable(SerializationFeature.INDENT_OUTPUT)
            disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
            registerModule(JavaTimeModule())
            propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE
        }
    }
}

// Custom exception for validation errors
class ValidationException(val errors: List<ValidationError>) : Exception()

fun Application.configureRouting() {
    routing {
        route("/api/v1") {

            // Health check endpoint
            get("/health") {
                val threadInfo = mapOf(
                    "thread_name" to Thread.currentThread().name,
                    "is_virtual" to Thread.currentThread().isVirtual
                )
                call.respond(
                    HttpStatusCode.OK,
                    mapOf(
                        "status" to "healthy",
                        "timestamp" to System.currentTimeMillis(),
                        "thread_info" to threadInfo
                    )
                )
            }

            // User endpoints
            route("/users") {
                // Get all users
                get {
                    call.respond(
                        HttpStatusCode.OK,
                        listOf(
                            User(1, "john_doe", "john@example.com"),
                            User(2, "jane_smith", "jane@example.com")
                        )
                    )
                }

                // Get user by ID
                get("/{id}") {
                    val id = call.parameters["id"]?.toIntOrNull()
                    if (id == null) {
                        call.respond(
                            HttpStatusCode.BadRequest,
                            mapOf("error" to "Invalid user ID")
                        )
                        return@get
                    }

                    // Simulate user lookup
                    val user = when (id) {
                        1 -> User(1, "john_doe", "john@example.com")
                        2 -> User(2, "jane_smith", "jane@example.com")
                        else -> null
                    }

                    if (user != null) {
                        call.respond(HttpStatusCode.OK, user)
                    } else {
                        call.respond(
                            HttpStatusCode.NotFound,
                            mapOf("error" to "User not found")
                        )
                    }
                }

                // Create new user
                post {
                    val createUserRequest = call.receive<CreateUserRequest>()

                    // Validate request
                    validateCreateUserRequest(createUserRequest)

                    // Create user (simulate)
                    val newUser = User(
                        id = 3, // Would be generated by database
                        name = createUserRequest.username,
                        email = createUserRequest.email
                    )

                    call.respond(HttpStatusCode.Created, newUser)
                }

                // Update user
                put("/{id}") {
                    val id = call.parameters["id"]?.toIntOrNull()
                    if (id == null) {
                        call.respond(
                            HttpStatusCode.BadRequest,
                            mapOf("error" to "Invalid user ID")
                        )
                        return@put
                    }

                    val updateUserRequest = call.receive<UpdateUserRequest>()

                    // Validate request
                    validateUpdateUserRequest(updateUserRequest)

                    // Update user (simulate)
                    val updatedUser = User(
                        id = id,
                        name = updateUserRequest.username ?: "existing_username",
                        email = updateUserRequest.email ?: "existing@email.com"
                    )

                    call.respond(HttpStatusCode.OK, updatedUser)
                }

                // Delete user
                delete("/{id}") {
                    val id = call.parameters["id"]?.toIntOrNull()
                    if (id == null) {
                        call.respond(
                            HttpStatusCode.BadRequest,
                            mapOf("error" to "Invalid user ID")
                        )
                        return@delete
                    }

                    call.respond(
                        HttpStatusCode.OK,
                        mapOf("message" to "User deleted successfully")
                    )
                }
            }
        }
    }
}

//data class User(
//    val id: Int,
//    val username: String,
//    val email: String,
//    val age: Int
//)

data class CreateUserRequest(
    val username: String,
    val email: String,
    val age: Int
)

data class UpdateUserRequest(
    val username: String? = null,
    val email: String? = null,
    val age: Int? = null
)


fun validateCreateUserRequest(request: CreateUserRequest) {
    val validation = Validation<CreateUserRequest> {
        CreateUserRequest::username {
            minLength(3)
            maxLength(50)
            pattern("^[a-zA-Z0-9_]+$") hint "Username must contain only letters, numbers, and underscores"
        }
        CreateUserRequest::email {
            pattern("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$") hint "Must be a valid email address"
        }
        CreateUserRequest::age {
            minimum(13) hint "Age must be at least 13"
            maximum(120) hint "Age must be less than 120"
        }
    }

    val result = validation.validate(request)
    if (result is Invalid) {
        throw ValidationException(result.errors)
    }
}

fun validateUpdateUserRequest(request: UpdateUserRequest) {
    val validation = Validation<UpdateUserRequest> {
        UpdateUserRequest::username ifPresent {
            minLength(3)
            maxLength(50)
            pattern("^[a-zA-Z0-9_]+$") hint "Username must contain only letters, numbers, and underscores"
        }
        UpdateUserRequest::email ifPresent {
            pattern("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$") hint "Must be a valid email address"
        }
        UpdateUserRequest::age ifPresent {
            minimum(13) hint "Age must be at least 13"
            maximum(120) hint "Age must be less than 120"
        }
    }

    val result = validation.validate(request)
    if (result is Invalid) {
        throw ValidationException(result.errors)
    }
}